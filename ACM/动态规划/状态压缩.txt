import java.util.Scanner;

public class Main {

	private static boolean judge(int cows0, int cows1, int fields) {// 上一行的牛，这一行的牛，这一行的草地
		if ((cows0 & cows1) == 0 && ((cows1 << 1) & cows1) == 0 && (cows1 == (cows1 & fields))) {
			return true;
		}
		return false;
	}

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int row = scanner.nextInt();
		int col = scanner.nextInt();
		int[] map = new int[row];// 每一行用二进制串表示
		for (int i = 0; i < row; ++i) {
			int r = 0;
			for (int j = 0; j < col; ++j) {
				int e = scanner.nextInt();
				if (e == 0)
					r = r << 1;
				else
					r = (r << 1) + 1;
			}
			map[i] = r;
		}

		int upper = (1 << col) - 1;// 表示每一行奶牛选择的状态对应二进制串的上确界
		int[][] dp = new int[row][1 << col];// dp[i][s]表示考虑第i行的时候，奶牛分布状态为s的情况下可以分布的种类

		// 初始化第一行
		for (int s = 0; s <= upper; ++s) {
			if (((s << 1) & s) == 0 && s == (s & map[0])) {// 没有出现相邻的奶牛，且都在草地上
				dp[0][s] = 1;
			}
		}
		
		for (int i = 1; i < row; ++i) {// 遍历行
			for (int s = 0; s <= upper; ++s) {// 遍历当前行的可行状态
				for (int preS = 0; preS <= upper; ++preS) {// 遍历之前行的可行状态
					if (judge(preS, s, map[i])) {
						dp[i][s] += dp[i - 1][preS];// 可能preS并不是真正的可行，但是由于其对应的dp为0所以不影响
					}
				}
			}
		}
		int result = 0;
		for (int s = 0; s <= upper; ++s) {
			result = (result + dp[row - 1][s]) % 100000000;
		}
		System.out.println(result);
		scanner.close();
	}
}